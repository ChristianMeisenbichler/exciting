#! /bin/sh
#
# takes a fortran module file and prints all variable
# symbols (without brackets for arrays).
#
# LIMITATIONS: 
# - works if not more than ONE variable per line is
# declared!!!
# The case 
#
#   integer, dimension(3,3) :: m
#
# is not possible!
#
# - Arrays always have to be declared like
#
#   integer :: m(3,3)
#
# with the dimension attached to the symbol name.
#
# - works only for one module per file.
#
# Author: S. Sagmeister, 26/06/2006
#

# check if all parameters are present
if [ $# -ne 2 ]; then
    echo "Wrong number of arguments"
    echo "Syntax: `basename $0`: module_name routine_name"
    exit
fi

# check for module file
file=$1
if [ ! -f $file ]; then
	echo "No file $file present"
	exit
fi

# set name of routine to write the fortran source code to
routine_nam=$2
routine_symb=`basename $routine_nam .f90`

cat <<EOF

Generating subroutine "$routine_nam" to dump variables in binary format from
module "$file"...
EOF

# all variables and parameters
allvarspars=`cat $file | awk -F'!' '{print $1}' | awk 'NF>0' | awk '/logical|character|integer|real|complex/' | awk '{print $NF}' | awk -F'(' '{print $1}' | awk -F'=' '{print $1}' | sort`

# all variables and NO parameters
allvars=`cat $file | awk -F'!' '{print $1}' | awk 'NF>0' | grep -v ', *parameter' | awk '/logical|character|integer|real|complex/' | awk '{print $NF}' | awk -F'(' '{print $1}' | awk -F'=' '{print $1}' | sort`

# scalars
allvarspars_scalars=`cat $file | awk -F'!' '{print $1}' | awk 'NF>0' | awk '/logical|character|integer|real|complex/' | awk '{print $NF}' | awk -F'=' '{print $1}'| grep -v '(' | sort`

# arrays
allvarspars_arrays=`cat $file | awk -F'!' '{print $1}' | awk 'NF>0' | awk '/logical|character|integer|real|complex/' | awk '{print $NF}' | awk -F'=' '{print $1}' |grep '(' | awk -F'(' '{print $1}' | sort`

# get module name
modnam=`grep ' *module' $file | grep -v 'end *module' | awk '{print $2}'`

#
# generate fortran source code to dump variables
#

# prolog
cat <<EOF > $routine_nam

!
! Automatically generated by "`basename $0`" - script
! Date: `date`
!

subroutine $routine_symb(fnam,fu_in)
use $modnam
implicit none
! file name to dump into
character(*), intent(in) :: fnam
! file unit
integer, intent(in) :: fu_in

! local variables
integer :: fu

! set file unit
fu = fu_in

! open file
open(fu,file=trim(fnam), form='unformatted', action='write', status='replace')

! all variables
EOF

# loop over variables
for variable in $allvarspars; do

cat <<EOF  >> $routine_nam
write(fu) $variable
EOF

done

# epilog
cat <<EOF  >> $routine_nam

! close file variables
close(fu)

end subroutine $routine_symb

EOF

cat <<EOF
done.

EOF

#
